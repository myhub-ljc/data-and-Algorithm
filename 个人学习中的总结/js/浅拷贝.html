<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>浅拷贝</title>
</head>
<body>
  <!--
    首先什么是拷贝？
    let arr = [1, 2, 3];
    let newArr = arr;
    newArr[0] = 100;

    console.log(arr);//[100, 2, 3]
    这是直接赋值的情况，不涉及任何拷贝。当改变newArr的时候，由于是同一个引用，arr指向的值也跟着改变。

    //现在进行浅拷贝
    let arr = [1,2,3]
    let newArr = arr.slice()
    newArr[0] = 100;
    console.log(arr)
    当修改newArr的时候，arr的值并不改变。什么原因?因为这里newArr是arr浅拷贝后的结果，newArr和arr现在引用的已经不是同一块空间啦！

    //那么实现浅拷贝的方法都有哪些呢？
    方法一：concat实现
    let arr = [1, 2, 3]
    let newArr = arr.concat()
    newArr[2] = 4
    console.log(arr)
    console.log(newArr)

    方法二：slice实现
    let arr = [1,2,3]
    let newArr = arr.slice()
    newArr[2] = 4
    console.log(arr)
    console.log(newArr)

    方法三：ES6的扩展运算符实现
    let arr = [1,2,3]
    let newArr = [...arr]
    newArr[2] = 4
    console.log(arr)
    console.log(newArr)

    方法四：使用Object.assign()
    let obj = {name: 'kobe', age: 18}
    const obj2 = Object.assign({}, obj, {name: 'james'})
    console.log(obj)
    console.log(obj2)

    方法五： 原生js实现
    const shallowClone = (target) => {
      if(typeof target === "object" && target !== null) {
        const cloneTarget = Array.isArray(target) ? [] : {}
        for(let prop in target) {
          if(target.hasOwnProperty(prop)) {
            cloneTarget[prop] = target[prop]
          }
        }
        return cloneTarget
      } else {
        return target
      }
    }
    //测试一下
    let arr = {name: 'me'}
    newArr = shallowClone(arr)
    newArr.name = 'youi'
    console.log(arr)
    console.log(newArr)
  -->
  <script>
    
  </script>
</body>
</html>