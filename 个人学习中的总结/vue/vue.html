<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>vue</title>
</head>
<body>
  <!--
    0.那你能讲一讲MVVM吗？
    答：MVVM是model-view-viewmodel的缩写,也就是把MVC中的controller演变成了viewmodel。
    Model代表数据层,View代表视图层,viewmodel是view层和model层的桥梁,数据会绑定到viewmodel层并将数据渲染到页面中,视图变化的时候也会通知viewmodel层更新数据

    1.简单说一下Vue2.x响应式数据原理
    答: vue在初始化数据时，会使用Object.Property重新定义data中的所有属性，当页面使用对应的属性时，首先会进行依赖收集(也就是收集当前组件的watcher)，如果属性发生变化时，会通知相关依赖进行更新操作(也就是发布订阅)

    2.那你知道Vue3.x响应式数据原理吗？
    答：vue3.x使用Proxy替代了Object.Property。因为Proxy可以直接监听数组和对象的变化
    Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？
    答：判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。
    监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？
    我们可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。

    3,说说你对SPA单页面的理解,它的优缺点是什么？
    答：个人理解：SPA仅在页面初始化时加载相应的html,css和js。一旦页面加载完成，单页应用就不会因为用户的操作而重新加载页面，取而代之的是利用路由机制实现html内容的切换，从而避免了页面的重新加载。
    
    优点：(1)重点是用户的体验好，快，内容的改变不需要重新加载整个页面，同时也避免了不必要的跳转和渲染。(2)正是基于这一点，单页面对服务器的压力也能小点。
    (3)前后端职责分离，前端负责交互，后端负责数据处理.

    缺点：(1)初次加载耗时长：为了实现页面初次加载的应用功能和效果，js和css必须统一加载，部分页面按需加载。
    (2)前进后退的路由管理：由于单页应用在同一个页面内加载内容，所以不能使用浏览器的前进后退功能，所有的页面切换都需要自己建立栈堆管理。
    (3)SEO难度较大：由于所有内容都是在一个页面中进行动态切换，所以在SEO上有着其天然的弱势。

    4,v-show和v-if有什么区别？
    答：v-if是真正的条件渲染，存在重建和销毁；而v-show只是利用css的display简单的进行隐藏和显示而已，因此不管条件是什么元素都会被渲染。所以v-if用在切换场景少的情况，而v-show则相反。

    5,class与style如何动态绑定？
    答：class可以通过对象或者数组语法进行动态绑定

    对象语法：
    <div v-bind:class="{isText: isTrue}"></div>
    data() {
    return {isTrue: true}}

    数组语法：
    <div v-bind:class="[isText? isTrue:""]"></div>
    data() {
    return {isTrue: true}}

    style也可以通过对象或者数组语法进行动态绑定
    
    对象语法：
    <div v-bind:style="{color: activeColor}"></div>
    data:{activeColor: 'red'}

    数组语法：
    <div v-bind:style="[styleColor, styleSize]"></div>
    data: {
      styleColor: {
        color: 'red'
      },
      styleSize:{
        fontSize:'23px'fasheng
      }
    }

    6，怎样理解Vue的单向数据流？
    答：父级prop的更新会向下流动到子组件中，但是反过来则不行。这样可以防止子组件意外改变父组件的状态，从而导致你的应用的数据流向难以理解。
    额外的，每次父级组件发生更新时，子组件中所有的prop都将会刷新为最新的值。这意味着你不应该一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改。

    7，直接给一个数组项赋值，Vue 能检测到变化吗？
    答：由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：

    当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue
    当你修改数组的长度时，例如：vm.items.length = newLength

    为了解决第一个问题，Vue 提供了以下操作方法：
    // Vue.set
    Vue.set(vm.items, indexOfItem, newValue)
    // vm.$set，Vue.set的一个别名
    vm.$set(vm.items, indexOfItem, newValue)
    // Array.prototype.splice
    vm.items.splice(indexOfItem, 1, newValue)

    为了解决第二个问题，Vue 提供了以下操作方法：

    // Array.prototype.splice
    vm.items.splice(newLength)

    8，谈谈你对vue生命周期的理解
    答：
  -->
  
</body>
</html>