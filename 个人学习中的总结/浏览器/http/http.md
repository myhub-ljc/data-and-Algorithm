1，HTTP的报文结构是怎样的？

HTTP是由起始行+头部+空行+实体

但http请求报文和响应报文是有一定区别的；

起始行
对于请求报文来说，它的起始行为：方法+路径+http版本(GET/home HTTP/1.1)
而对于响应报文来说，它的起始行为；http版本+状态码+原因(HTTP/1.1 200 ok)
值得注意的是，在起始行中，每两个部分之间用空格隔开，最后一个部分后面应该接一个换行，严格遵循ABNF语法规范。

头部
不管是请求头还是响应头，其中的字段是相当多的，而且牵扯到http非常多的特性，这里就不一一列举的，重点看看这些头部字段的格式：

字段名不区分大小写
字段名不允许出现空格，不可以出现下划线_
字段名后面必须紧接着:

空行
很重要，用来区分开头部和实体。

问: 如果说在头部中间故意加一个空行会怎么样？
那么空行后的内容全部被视为实体。

实体
就是具体的数据了，也就是body部分。请求报文对应请求体, 响应报文对应响应体。

2，如何理解HTTP的请求方法？

有哪些请求方法？
http/1.1规定了以下请求方法(注意，都是大写):
GET：通常用来获取资源
POST：提交数据，即上传数据
PUT: 修改数据
DELETE: 删除数据(很少用到)
HEAD: 获取资源的元信息
OPTIONS: 列出可对资源实行的请求方法，用来进行跨域请求
TRACE: 追踪请求-响应的传输路径

GET和POST有什么区别？
首先最直观的便是语义上的区别
下面是一些具体的差别
从缓存的角度：GET请求默认会被浏览器缓存下来，而POST请求则不会；
从编码的角度：GET只能进行URL编码，只能接收ASCLL字符，而POST不受限制;
从参数的角度：GET请求将参数放在URL中，因此不安全，而POST将参数放在请求体中，更适合传输敏感信息；
从幂等性角度：GET是幂等的(幂等表示执行相同的操作，得到相同的结果)，而POST不是；
从TCP角度：GET请求将请求报文一次性发出去，而POST请求是分为两个TCP数据包，首先发送header部分，如果服务器响应100(continue)，然后发送body部分。(火狐浏览器除外)

3，如何理解URI？
URI(uniform resource Identifier)，也就是统一资源标识符，它的作用就是区分互联网上不同的资源。
但是，它并不是我们常说的网址URL，因为实际上URL包含了两部分URN和URL两个部分，由于URL过于普及，所以大多人就将URL默认为URI了。

4，如何理解HTTP状态码？
HTTP状态码被分为五类：
·1xx：表示正是协议处理的中间状态，还需要后续操作；
·2xx：表示成功状态；
·3xx：重定向状态，资源位置发生变动，需重新发送请求；
·4xx：请求报文有错误；
·5xx：服务端发生错误；

接下来就一一分析各个类型的状态码

1xx
101 switching protocols 在HTTP升级为websocket的时候，如果服务器同意变更，则返回状态码101；

2xx
200 ok 是最常见的成功状态码，通常在响应体中放有数据。
204 no content含义与200相同，但是响应头中没有body数据。
206 partial content表示部分内容，它的使用场景为HTTP分块下载和断点续传，也会带上响应头字段content-range.

3xx
301 moved permanently即永久重定向，对应着302 found，即临时重定向
比如你的网站从http升级为https了，以前的站点再也不用了，应当返回301，这个时候浏览器会默认做缓存优化，在第二次访问时会自动访问重定向的那个网址。
而如果是暂时不用，那么直接返回302即可，和301不同的是，浏览器并不会做缓存优化。

4xx
400 bad request 开开发者经常看到一头雾水，只是笼统地提示了一下错误，并不知道哪里出错了。
403 forbidden 这实际上并不是请求报文出错，而是服务器禁止访问，原因有很多：比如法律禁止，敏感信息。
404 not found 表示在服务器上没有对应的资源。
405 method not found 请求方法不被服务器允许。
408 request timeout 服务器等待了太长时间。
409 conflict 多个请求发生了冲突。

5xx
500 internal server error 仅仅告诉你服务器出错误了，出了啥错误咱们也不知道。
501 not implemented 表示客户端请求的功能还不支持。
502 bad gateway 服务器自身是正常的，但访问的时候出错了，啥错误咱们也不知道。
503 service unavaliable 表示服务器当前很忙，暂时无法响应服务。

5，简要概括一下HTTP的特点，HTTP有哪些缺点呢？
HTTP的特点概括如下：
(1)灵活可扩展：主要体现在两个方面：一是：语义上的自由，只规定了基本格式，比如空格分隔单词，换行分隔字段，其他的各个部分并没有明确规定。二是：传输的多样性，不仅仅可以传输文本，还能传输图片，视频等任意数据很方便。
(2)可靠传输：HTTP基于TCP/IP，因此把这一特性继承了下来。
(3)请求-应答：也就是一发一回，有来有回；当然这个请求方和应答方不单单指客户端和服务器之间，如果某台服务器作为代理来连接后端的服务端，那么这台服务器也会扮演请求方的角色。
(4)无状态：这里的状态是指通信过程的上下文信息，而每次 http 请求都是独立、无关的，默认不需要保留状态信息。

HTTP 缺点
(1)无状态
所谓的优点和缺点还是要分场景来看的，对于 HTTP 而言，最具争议的地方在于它的无状态。
在需要长连接的场景中，需要保存大量的上下文信息，以免传输大量重复的信息，那么这时候无状态就是 http 的缺点了。
但与此同时，另外一些应用仅仅只是为了获取一些数据，不需要保存连接上下文信息，无状态反而减少了网络开销，成为了 http 的优点。

(2)明文传输
即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。
这当然对于调试提供了便利，但同时也让 HTTP 的报文信息暴露给了外界，给攻击者也提供了便利。WIFI陷阱就是利用 HTTP 明文传输的缺点，诱导你连上热点，然后疯狂抓你所有的流量，从而拿到你的敏感信息。

(3)队头阻塞问题
当 http 开启长连接时，共用一个 TCP 连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，其它的请求只能处于阻塞状态，也就是著名的队头阻塞问题。


6，对于定长和不定长的数据，HTTP是怎么传输的？
定长包体
对于定长包体而言，发送端在传输的时候一般会带上content-length，来指明包体的长度。(content-length对于http的传输过程起了十分重要的作用，如果设置不当会导致传输失败)

不定长包体
这里就必须介绍一个http头部字段了：
transfer-encoding: chunked
表示分块传输数据，设置这个字段后会产生两个效果：
·content-length 属性会被忽略
基于长连接会持续推送内容

7，HTTP是如何处理大文件的传输？
对于几百 M 甚至上 G 的大文件来说，如果要一口气全部传输过来显然是不现实的，会有大量的等待时间，严重影响用户体验。因此，HTTP 针对这一场景，采取了范围请求的解决方案，允许客户端仅仅请求一个资源的一部分。

如何支持
当然，前提是服务器要支持范围请求，要支持这个功能，就必须加上这样一个响应头:
Accept-Ranges: none
用来告诉客户端服务器是支持范围请求的。

range字段拆解
而对于浏览器而言，它需要指定请求数据的哪一部分，通过range这个请求头字段确定，格式为bytes=x-y
·0-499表示从开始到499个字节
·500-表示从第500个字节到文件终点
·-100表示文件的最后100个字节

服务器收到请求后，首先验证范围是否合法，如果越界了就返回416错误码，否则读取相应片段，并返回206状态码。

同时，服务器需要有conten-range字段，这个字段的格式跟根据请求头中range字段的不同而有所差异。

8，HTTP中如何处理表单数据的提交?
在 http 中，有两种主要的表单提交的方式，体现在两种不同的Content-Type取值:

application/x-www-form-urlencoded
multipart/form-data

由于表单提交一般是POST请求，很少考虑GET，因此这里我们将默认提交的数据放在请求体中.

application/x-www-form-urlencoded
对于application/x-www-form-urlencoded格式的表单内容，有以下特点:

其中的数据会被编码成以&分隔的键值对
字符以URL编码方式编码。

multipart/form-data
对于multipart/form-data而言:
请求头中的Content-Type字段会包含boundary，且boundary的值有浏览器默认指定。例: Content-Type: multipart/form-data;boundary=----WebkitFormBoundaryRRJKeWfHPGrS4LKe。

而且，在实际的场景中，对于图片等文件的上传，基本采用multipart/form-data而不用application/x-www-form-urlencoded，因为没有必要做 URL 编码，带来巨大耗时的同时也占用了更多的空间。

9，HTTP1.1如何解决HTTP的对头阻塞问题？
首先应清楚什么是HTTP的对头阻塞问题
HTTP 传输是基于请求-应答的模式进行的，报文必须是一发一收，但值得注意的是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是著名的HTTP队头阻塞问题。

并发连接
对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。在RFC2616规定过客户端最多并发 2 个连接，不过事实上在现在的浏览器标准中，这个上限要多很多，Chrome 中是 6 个。
但其实，即使是提高了并发连接，还是不能满足人们对性能的需求。

域名分片
一个域名不是可以并发 6 个长连接吗？那我就多分几个域名。
比如 content1.sanyuan.com 、content2.sanyuan.com。
这样一个sanyuan.com域名下可以分出非常多的二级域名，而它们都指向同样的一台服务器，能够并发的长连接数更多了，事实上也更好地解决了队头阻塞的问题。

10，对cookie了解多少？
