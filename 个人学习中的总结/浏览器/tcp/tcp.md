TCP作为传输层的协议，是一个软件工程师素养的体现，也是面试中经常被问到的知识点。

001，能不能说一下TCP和UDP的区别？

首先概括一下基本的区别：
TCP是一个面向连接的，可靠的，基于字节流的传输层协议；
而UDP是一个面向无连接的传输层协议；

再具体来分析下两者的区别(和UDP相比，TCP有三大核心特性)
1，面向连接：所谓的连接，指的是客户端和服务器的连接，在双方互相通信之前，TCP需要三次握手建立连接，而UDP没有相应建立连接的过程。
2，可靠性：TCP花了很多功夫保证连接的可靠，这个可靠性体现在哪些方面呢？
一个是有状态(TCP会记录发送了哪些数据，哪些数据被接收了，哪些数据没有被接收，而且也保证了数据包的有序到达，不允许出半点差错，这就是有状态)
另一个是可控制(当意识到数据包出错或者网络环境不好时，会根据相应的情况做出调整，比如：减缓数据的传输速度或者重新发送，这就是可控制)
3，面向字节流：UDP的数据传输是基于数据包的，这是因为仅仅继承了Ip层的特性；而TCP为了维护状态，将一个个Ip包变成了字节流。

002，说说TCP三次握手的过程？为什么是三次而不是两次或者四次呢？
其实 我个人的理解就是：就是要确认客户端和服务器之间都有接收和发送的能力。
第一次握手：(客户端发送SYN)-->服务器
第二次握手：(服务器接收到后，也发送SYN和ACK) --> 客户端
第三次握手：(客户端接收到后，也发送ACK) --> 服务器
需要注意的是发送SYN需要对端进行确认所以会消耗一个序列号，而ACK不需要。


为什么不是两次？
很简单，无法确认客户端是否具有接收的能力。
分析如下:
如果是两次，你现在发了 SYN 报文想握手，但是这个包滞留在了当前的网络中迟迟没有到达，TCP 以为这是丢了包，于是重传，两次握手建立好了连接。
看似没有问题，但是连接关闭后，如果这个滞留在网路中的包到达了服务端呢？这时候由于是两次握手，服务端只要接收到然后发送相应的数据包，就默认建立连接，但是现在客户端已经断开了。
看到问题的吧，这就带来了连接资源的浪费。

为什么不是四次？
也很简单，因为前三次已经确认了客户端和服务器都有接收和发送的能力，所以发送100次都可以。

三次握手过程中可以携带数据吗？
第三次握手的时候可以携带，而前两次不可以携带数据。

如果前两次握手能够携带数据，那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放大量数据，那么服务器势必会消耗更多的时间和内存空间去处理这些数据，增大了服务器被攻击的风险。
第三次握手的时候，客户端已经处于ESTABLISHED状态，并且已经能够确认服务器的接收、发送能力正常，这个时候相对安全了，可以携带数据。

同时打开会怎么样呢？
如果双方同时发送SYN呢，这也是一个会发生的情况。
在发送方给接收方发SYN报文的同时，接收方也给发送方发SYN报文，两个人刚上了!
发完SYN，两者的状态都变为SYN-SENT。
在各自收到对方的SYN后，两者状态都变为SYN-REVD。
接着会回复对应的ACK + SYN，这个报文在对方接收之后，两者状态一起变为ESTABLISHED。
这就是同时打开情况下的状态变迁。

003，说说TCP的四次挥手？
刚开始双方都处于establied(已确认)的状态
客户端要断开了，就会向服务器发送FIN报文，发送后客户端变成了FIN-WAIT-1状态；
服务器收到后向客户端确认，此时变成了CLOSE-WAIT状态；
客户端收到了服务器的确认后，此时变成了FIN-WAIT-2状态；
随后，服务器向客户端发送FIN，自己进入LAST-ACK状态；
客户端收到服务器的FIN，自己变成了TIME-WAIT状态，然后发送ACK给服务端。
注意了，这个时候，客户端需要等待足够长的时间，具体来说，是 2 个 MSL(Maximum Segment Lifetime，报文最大生存时间), 在这段时间内如果客户端没有收到服务端的重发请求，那么表示 ACK 成功到达，挥手结束，否则客户端重发 ACK。



